<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /mnt/sda1/Dissertation/grobid/grobid-0.5.6/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Multi-agent reinforcement learning</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2019-12-22">December 22, 2019</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Schnebli</forename><surname>Zoltan</surname></persName>
						</author>
						<title level="a" type="main">Multi-agent reinforcement learning</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2019-12-22">December 22, 2019</date>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.5.6" ident="GROBID" when="2019-12-24T15:31+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Lightweight LCP Construction
for Next-Generation Sequencing Datasets
.=</p>
<p>M. J. Bauer1, A. J. Cox1, G. Rosone2, M. Sciortino2
.=</p>
<p>1 Computational Biology Group, Illumina Cambridge Ltd., United Kingdom
2 Dipartimento di Matematica e Informatica, University of Palermo, Italy
.=</p>
<p>Ljubljana, 10-12 September 2012
WABI 2012.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Introduction Problem
.=</p>
<p>Whole human genome sequencing
.=</p>
<p>Modern DNA sequencing machines produce a lot of data! e.g.
Illumina HiSeq 2000: > 40Gbases of sequence per day (paired
100-mers).
.=</p>
<p>Datasets of 100 Gbases or more are common.
.=</p>
<p>Many bioinformatics applications, e.g. the rapid search for maximal
exact matches, shortest unique substrings and shortest absent words,
use the SA (Suffix Array) and/or BWT (Burrows-Wheeler Transform)
together with an additional table: the LCP (Longest Common Prefix)
array.
.=</p>
<p>Together, SA/BWT and LCP can replace the larger suffix tree.
.=</p>
<p>Goal: Lightweight LCP Construction for Next-Generation
Sequencing Datasets, i.e. for a large collection of short sequences..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>$-segment
.=</p>
<p>A-segment
.=</p>
<p>C-segment
.=</p>
<p>G-segment
.=</p>
<p>T-segment
.=</p>
<p>Introduction Preliminaries
.=</p>
<p>Let v a sequence on an alphabet of σ letters of length k.
SA[i]: The starting position of the ith smallest suffix of v.
BWT[i]: The symbol that (circularly) precedes the first symbol of the suffix.
LCP[i]: The length of longest common prefix with preceding suffix in the list of sorted
suffix.
.=</p>
<p>Example
0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>v= G C A C T G T A C C A A C $
.=</p>
<p>SA LCP BWT Sorted Suffixes of v
0 13 0 C $
1 10 0 C AAC$
2 11 1 A AC$
3 7 2 T ACCAAC$
4 2 2 C ACTGTACCAAC$
5 12 0 A C$
6 9 1 C CAAC$
7 1 2 G CACTGTACCAAC$
8 8 1 A CCAAC$
9 3 1 A CTGTACCAAC$
10 0 0 $ GCACTGTACCAAC$
11 5 1 T GTACCAAC$
12 6 0 G TACCAAC$
13 4 1 C TGTACCAAC$
.=</p>
<p>For instance, the suffix ACCAAC$ is the 6-suffix of v and the symbol T in the BWT precedes
such suffix.
.=</p>
<p>Definition
.=</p>
<p>j-suffix of v is the last j non-$ symbols of that string and 0-suffix of v is $.
.=</p>
<p>Helpful to think of BWT and LCP as being in σ + 1 “segments” labelled according to first
symbol of “associated” suffix..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Introduction Preliminaries
.=</p>
<p>Let v a sequence on an alphabet of σ letters of length k.
SA[i]: The starting position of the ith smallest suffix of v.
BWT[i]: The symbol that (circularly) precedes the first symbol of the suffix.
LCP[i]: The length of longest common prefix with preceding suffix in the list of sorted
suffix.
.=</p>
<p>Example
0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>v= G C A C T G T A C C A A C $
.=</p>
<p>SA LCP BWT Sorted Suffixes of v
0 13 0 C $ $-segment
1 10 0 C AAC$
2 11 1 A AC$
.=</p>
<p>A-segment
3 7 2 T ACCAAC$
4 2 2 C ACTGTACCAAC$
5 12 0 A C$
6 9 1 C CAAC$
7 1 2 G CACTGTACCAAC$ C-segment
8 8 1 A CCAAC$
9 3 1 A CTGTACCAAC$
10 0 0 $ GCACTGTACCAAC$
.=</p>
<p>G-segment
11 5 1 T GTACCAAC$
12 6 0 G TACCAAC$
.=</p>
<p>T-segment
13 4 1 C TGTACCAAC$
.=</p>
<p>For instance, the suffix ACCAAC$ is the 6-suffix of v and the symbol T in the BWT precedes
such suffix.
.=</p>
<p>Definition
.=</p>
<p>j-suffix of v is the last j non-$ symbols of that string and 0-suffix of v is $.
.=</p>
<p>Helpful to think of BWT and LCP as being in σ + 1 “segments” labelled according to first
symbol of “associated” suffix..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Introduction Preliminaries
.=</p>
<p>Let S = {S1, S2, . . . , Sm} be a collection of strings on an alphabet of σ
letters. The sum of lengths of Si is N .
.=</p>
<p>GSA[i]: The i-th smallest suffix of the strings in S. If GSA[i]=(t,h), then it corresponds to
the suffix starting at the position t of the string Sh.
BWT[i]: The symbol that (circularly) precedes the first symbol of the suffix of Sh.
LCP[i]: The length of longest common prefix with preceding suffix in the sorted list of the
suffixes of S.
.=</p>
<p>Example GSA LCP BWT Sorted Suffixes of S
(6, 1) 0 C $1 $-segment
(6, 2) 0 C $2
(6, 3) 0 T $3
(3, 1) 0 C AAC$1
(4, 1) 1 A AC$1 A-segment
(1, 2) 1 G AGCTC$2
(5, 1) 0 A C$1
(5, 2) 1 T C$2
.=</p>
<p>0 1 2 3 4 5 6 (2, 1) 1 C CAAC$1
S1 G C C A A C $1 (1, 1) 1 G CCAAC$1 C-segment
S2 G A G C T C $2 (1, 3) 1 T CGCTT$3
S3 T C G C T T $3 (3, 2) 1 G CTC$2
.=</p>
<p>(3, 3) 2 G CTT$3
(0, 2) 0 $2 GAGCTC$2
(0, 1) 1 $1 GCCAAC$1 G-segment
(2, 2) 2 A GCTC$2
(2, 3) 3 C GCTT$3
(5, 3) 0 T T$3
(4, 2) 1 C TC$2 T-segment
(0, 3) 2 $3 TCGCTT$3
(4, 3) 1 C TT$3
.=</p>
<p>For instance, the suffixes CAAC$1, GCTC$2,GCTT$3 are the 4-suffixes of S.
.=</p>
<p>In general, j-suffix of Si ∈ S is the last j non-$ symbols of that string and 0-suffix of Si is $i..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>LCP of a massive collection of sequences Description
.=</p>
<p>A massive collection of sequences
.=</p>
<p>Input:
A massive collection S of m strings on an alphabet of σ letters.
Output:
The LCP array of S (mainly) working in external memory.
.=</p>
<p>Usual algorithms do not fit to handle collections of sequences. So
they concatenate sequences of S in order to obtain a single sequence.
.=</p>
<p>These algorithms
.=</p>
<p>compute the LCP from Suffix Array (Kasai et. al. 2001, Kärkkäinen et.
al. 2009, and so on).
But: (often) need to hold SA in RAM (Simpson and Durbin estimate
700Gbytes RAM for SA of 60 Gbases of data).
compute the LCP acting directly on the BWT of the string and does
not need its suffix array (Beller et. al. 2011).
But: they mainly work in internal memory..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>LCP of a massive collection of sequences Description
.=</p>
<p>Our idea
.=</p>
<p>Our algorithm computes the LCP of the collection S of sequences mostly
in external memory, storing some tables in internal memory:
.=</p>
<p>without concatenating the strings belonging to S.
.=</p>
<p>without pre-computing either the BWT or the (G)SA.
.=</p>
<p>It computes the LCP and the BWT at the same time.
.=</p>
<p>Building upon the method (called BCR ) of BWT computation (in external
memory) introduced in Bauer et al., our algorithm adds some lightweight
data structures and allows the LCP and BWT of a collection of strings to
be computed simultaneously.
.=</p>
<p>For further details on building of the BWT in external memory:
.=</p>
<p>M. J. Bauer, A. J. Cox, G. R., Lightweight algorithms for constructing and inverting the BWT
.=</p>
<p>of string collections, Theoretical Computer Science, Available online 10 February 2012..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>LCP of a massive collection of sequences Description
.=</p>
<p>Our algorithm extLCP
.=</p>
<p>Let S = {S1, S2, . . . , Sm} be a collection of strings.
.=</p>
<p>Definition
.=</p>
<p>j-suffix of Si ∈ S is the last j non-$ symbols of that string and
0-suffix of Si ∈ S is $i.
.=</p>
<p>Our algorithm
works incrementally via K iterations, where K is the maximal length
of the strings in S. At each of the iterations j = 1, 2, . . . ,K − 1, the
algorithm considers all the j-suffixes of S and computes
.=</p>
<p>a partial BWT string bwtj(S) by inserting the symbols preceding the
j-suffixes of S at their correct positions into bwtj−1(S)
a partial LCP array lcpj(S) by inserting the LCP-values of j-suffixes of
S and updating the LCP-values of suffixes already inserted.
.=</p>
<p>Each iteration j simulates the insertion of the j-suffixes in the suffix
array.
.=</p>
<p>This insertion does not affect the relative ordering of symbols inserted
during previous iterations..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A C A C T G T A C C A A C
.=</p>
<p>G A A C A G A A A G C T C
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example
.=</p>
<p>Let S = {S1, S2} = {ACACTGTACCAAC,GAACAGAAAGCTC} be
a collection of m = 2 strings of length k = 13 on an alphabet of σ = 4
letters.
.=</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>S1 $1
S2 $2
.=</p>
<p>At step j, we insert the symbols circularly preceding the j-suffixes into the
partial BWT and insert/update the LCP-values in the partial LCP.
.=</p>
<p>We do not need to keep the entire collection in internal memory. It is
enough to keep the symbols that we have to insert at the iteration j (red
symbols).
.=</p>
<p>We assume that $1 = $2 = $ and $ < A < C < G < T and the longest
common prefix between two end-markers is 0.
.=</p>
<p>Si[|Si|] = Sj [|Sj |] = $, and we define Si[|Si|] < Sj [|Sj |], if i < j..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A C A C T G T A C C A A
.=</p>
<p>G A A C A G A A A G C T
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example
.=</p>
<p>Let S = {S1, S2} = {ACACTGTACCAAC,GAACAGAAAGCTC} be
a collection of m = 2 strings of length k = 13 on an alphabet of σ = 4
letters.
.=</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>S1 C $1
S2 C $2
.=</p>
<p>At step j, we insert the symbols circularly preceding the j-suffixes into the
partial BWT and insert/update the LCP-values in the partial LCP.
.=</p>
<p>We do not need to keep the entire collection in internal memory. It is
enough to keep the symbols that we have to insert at the iteration j (red
symbols).
.=</p>
<p>We assume that $1 = $2 = $ and $ < A < C < G < T and the longest
common prefix between two end-markers is 0.
.=</p>
<p>Si[|Si|] = Sj [|Sj |] = $, and we define Si[|Si|] < Sj [|Sj |], if i < j..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A C A C T G T A C C A
.=</p>
<p>G A A C A G A A A G C
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example
.=</p>
<p>Let S = {S1, S2} = {ACACTGTACCAAC,GAACAGAAAGCTC} be
a collection of m = 2 strings of length k = 13 on an alphabet of σ = 4
letters.
.=</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>S1 A C $1
S2 T C $2
.=</p>
<p>At step j, we insert the symbols circularly preceding the j-suffixes into the
partial BWT and insert/update the LCP-values in the partial LCP.
.=</p>
<p>We do not need to keep the entire collection in internal memory. It is
enough to keep the symbols that we have to insert at the iteration j (red
symbols).
.=</p>
<p>We assume that $1 = $2 = $ and $ < A < C < G < T and the longest
common prefix between two end-markers is 0.
.=</p>
<p>Si[|Si|] = Sj [|Sj |] = $, and we define Si[|Si|] < Sj [|Sj |], if i < j..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A C A C T G T A C C
.=</p>
<p>G A A C A G A A A G
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example
.=</p>
<p>Let S = {S1, S2} = {ACACTGTACCAAC,GAACAGAAAGCTC} be
a collection of m = 2 strings of length k = 13 on an alphabet of σ = 4
letters.
.=</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>S1 A A C $1
S2 C T C $2
.=</p>
<p>At step j, we insert the symbols circularly preceding the j-suffixes into the
partial BWT and insert/update the LCP-values in the partial LCP.
.=</p>
<p>We do not need to keep the entire collection in internal memory. It is
enough to keep the symbols that we have to insert at the iteration j (red
symbols).
.=</p>
<p>We assume that $1 = $2 = $ and $ < A < C < G < T and the longest
common prefix between two end-markers is 0.
.=</p>
<p>Si[|Si|] = Sj [|Sj |] = $, and we define Si[|Si|] < Sj [|Sj |], if i < j..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A C A C T G T A C
.=</p>
<p>G A A C A G A A A
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example
.=</p>
<p>Let S = {S1, S2} = {ACACTGTACCAAC,GAACAGAAAGCTC} be
a collection of m = 2 strings of length k = 13 on an alphabet of σ = 4
letters.
.=</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>S1 C A A C $1
S2 G C T C $2
.=</p>
<p>At step j, we insert the symbols circularly preceding the j-suffixes into the
partial BWT and insert/update the LCP-values in the partial LCP.
.=</p>
<p>We do not need to keep the entire collection in internal memory. It is
enough to keep the symbols that we have to insert at the iteration j (red
symbols).
.=</p>
<p>We assume that $1 = $2 = $ and $ < A < C < G < T and the longest
common prefix between two end-markers is 0.
.=</p>
<p>Si[|Si|] = Sj [|Sj |] = $, and we define Si[|Si|] < Sj [|Sj |], if i < j..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A C A C T G T A
.=</p>
<p>G A A C A G A A
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example
.=</p>
<p>Let S = {S1, S2} = {ACACTGTACCAAC,GAACAGAAAGCTC} be
a collection of m = 2 strings of length k = 13 on an alphabet of σ = 4
letters.
.=</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>S1 C C A A C $1
S2 A G C T C $2
.=</p>
<p>At step j, we insert the symbols circularly preceding the j-suffixes into the
partial BWT and insert/update the LCP-values in the partial LCP.
.=</p>
<p>We do not need to keep the entire collection in internal memory. It is
enough to keep the symbols that we have to insert at the iteration j (red
symbols).
.=</p>
<p>We assume that $1 = $2 = $ and $ < A < C < G < T and the longest
common prefix between two end-markers is 0.
.=</p>
<p>Si[|Si|] = Sj [|Sj |] = $, and we define Si[|Si|] < Sj [|Sj |], if i < j..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A C A C T G T
.=</p>
<p>G A A C A G A
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example
.=</p>
<p>Let S = {S1, S2} = {ACACTGTACCAAC,GAACAGAAAGCTC} be
a collection of m = 2 strings of length k = 13 on an alphabet of σ = 4
letters.
.=</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>S1 A C C A A C $1
S2 A A G C T C $2
.=</p>
<p>At step j, we insert the symbols circularly preceding the j-suffixes into the
partial BWT and insert/update the LCP-values in the partial LCP.
.=</p>
<p>We do not need to keep the entire collection in internal memory. It is
enough to keep the symbols that we have to insert at the iteration j (red
symbols).
.=</p>
<p>We assume that $1 = $2 = $ and $ < A < C < G < T and the longest
common prefix between two end-markers is 0.
.=</p>
<p>Si[|Si|] = Sj [|Sj |] = $, and we define Si[|Si|] < Sj [|Sj |], if i < j..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A C A C T G
.=</p>
<p>G A A C A G
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example
.=</p>
<p>Let S = {S1, S2} = {ACACTGTACCAAC,GAACAGAAAGCTC} be
a collection of m = 2 strings of length k = 13 on an alphabet of σ = 4
letters.
.=</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>S1 T A C C A A C $1
S2 A A A G C T C $2
.=</p>
<p>At step j, we insert the symbols circularly preceding the j-suffixes into the
partial BWT and insert/update the LCP-values in the partial LCP.
.=</p>
<p>We do not need to keep the entire collection in internal memory. It is
enough to keep the symbols that we have to insert at the iteration j (red
symbols).
.=</p>
<p>We assume that $1 = $2 = $ and $ < A < C < G < T and the longest
common prefix between two end-markers is 0.
.=</p>
<p>Si[|Si|] = Sj [|Sj |] = $, and we define Si[|Si|] < Sj [|Sj |], if i < j..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A C A C T
.=</p>
<p>G A A C A
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example
.=</p>
<p>Let S = {S1, S2} = {ACACTGTACCAAC,GAACAGAAAGCTC} be
a collection of m = 2 strings of length k = 13 on an alphabet of σ = 4
letters.
.=</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>S1 G T A C C A A C $1
S2 G A A A G C T C $2
.=</p>
<p>At step j, we insert the symbols circularly preceding the j-suffixes into the
partial BWT and insert/update the LCP-values in the partial LCP.
.=</p>
<p>We do not need to keep the entire collection in internal memory. It is
enough to keep the symbols that we have to insert at the iteration j (red
symbols).
.=</p>
<p>We assume that $1 = $2 = $ and $ < A < C < G < T and the longest
common prefix between two end-markers is 0.
.=</p>
<p>Si[|Si|] = Sj [|Sj |] = $, and we define Si[|Si|] < Sj [|Sj |], if i < j..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A C A C
.=</p>
<p>G A A C
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example
.=</p>
<p>Let S = {S1, S2} = {ACACTGTACCAAC,GAACAGAAAGCTC} be
a collection of m = 2 strings of length k = 13 on an alphabet of σ = 4
letters.
.=</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>S1 T G T A C C A A C $1
S2 A G A A A G C T C $2
.=</p>
<p>At step j, we insert the symbols circularly preceding the j-suffixes into the
partial BWT and insert/update the LCP-values in the partial LCP.
.=</p>
<p>We do not need to keep the entire collection in internal memory. It is
enough to keep the symbols that we have to insert at the iteration j (red
symbols).
.=</p>
<p>We assume that $1 = $2 = $ and $ < A < C < G < T and the longest
common prefix between two end-markers is 0.
.=</p>
<p>Si[|Si|] = Sj [|Sj |] = $, and we define Si[|Si|] < Sj [|Sj |], if i < j..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A C A
.=</p>
<p>G A A
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example
.=</p>
<p>Let S = {S1, S2} = {ACACTGTACCAAC,GAACAGAAAGCTC} be
a collection of m = 2 strings of length k = 13 on an alphabet of σ = 4
letters.
.=</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>S1 C T G T A C C A A C $1
S2 C A G A A A G C T C $2
.=</p>
<p>At step j, we insert the symbols circularly preceding the j-suffixes into the
partial BWT and insert/update the LCP-values in the partial LCP.
.=</p>
<p>We do not need to keep the entire collection in internal memory. It is
enough to keep the symbols that we have to insert at the iteration j (red
symbols).
.=</p>
<p>We assume that $1 = $2 = $ and $ < A < C < G < T and the longest
common prefix between two end-markers is 0.
.=</p>
<p>Si[|Si|] = Sj [|Sj |] = $, and we define Si[|Si|] < Sj [|Sj |], if i < j..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A C
.=</p>
<p>G A
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example
.=</p>
<p>Let S = {S1, S2} = {ACACTGTACCAAC,GAACAGAAAGCTC} be
a collection of m = 2 strings of length k = 13 on an alphabet of σ = 4
letters.
.=</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>S1 A C T G T A C C A A C $1
S2 A C A G A A A G C T C $2
.=</p>
<p>At step j, we insert the symbols circularly preceding the j-suffixes into the
partial BWT and insert/update the LCP-values in the partial LCP.
.=</p>
<p>We do not need to keep the entire collection in internal memory. It is
enough to keep the symbols that we have to insert at the iteration j (red
symbols).
.=</p>
<p>We assume that $1 = $2 = $ and $ < A < C < G < T and the longest
common prefix between two end-markers is 0.
.=</p>
<p>Si[|Si|] = Sj [|Sj |] = $, and we define Si[|Si|] < Sj [|Sj |], if i < j..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A
.=</p>
<p>G
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example
.=</p>
<p>Let S = {S1, S2} = {ACACTGTACCAAC,GAACAGAAAGCTC} be
a collection of m = 2 strings of length k = 13 on an alphabet of σ = 4
letters.
.=</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>S1 C A C T G T A C C A A C $1
S2 A A C A G A A A G C T C $2
.=</p>
<p>At step j, we insert the symbols circularly preceding the j-suffixes into the
partial BWT and insert/update the LCP-values in the partial LCP.
.=</p>
<p>We do not need to keep the entire collection in internal memory. It is
enough to keep the symbols that we have to insert at the iteration j (red
symbols).
.=</p>
<p>We assume that $1 = $2 = $ and $ < A < C < G < T and the longest
common prefix between two end-markers is 0.
.=</p>
<p>Si[|Si|] = Sj [|Sj |] = $, and we define Si[|Si|] < Sj [|Sj |], if i < j..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>LCP of a massive collection of sequences Example
.=</p>
<p>Example
.=</p>
<p>Let S = {S1, S2} = {ACACTGTACCAAC,GAACAGAAAGCTC} be
a collection of m = 2 strings of length k = 13 on an alphabet of σ = 4
letters.
.=</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>S1 A C A C T G T A C C A A C $1
S2 G A A C A G A A A G C T C $2
.=</p>
<p>At step j, we insert the symbols circularly preceding the j-suffixes into the
partial BWT and insert/update the LCP-values in the partial LCP.
.=</p>
<p>We do not need to keep the entire collection in internal memory. It is
enough to keep the symbols that we have to insert at the iteration j (red
symbols).
.=</p>
<p>We assume that $1 = $2 = $ and $ < A < C < G < T and the longest
common prefix between two end-markers is 0.
.=</p>
<p>Si[|Si|] = Sj [|Sj |] = $, and we define Si[|Si|] < Sj [|Sj |], if i < j..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>C
.=</p>
<p>C
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example: Iteration 0
.=</p>
<p>Let S = {S1, S2} = {ACACTGTACCAAC,GAACAGAAAGCTC} be
a collection of m = 2 strings of length k = 13 on an alphabet of σ = 4
letters.
.=</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>S1 $1
S2 $2
.=</p>
<p>We assume that the first element of LCP array is 0. Recall that
lcp($1, $2) = 0. We obtain:
.=</p>
<p>L0($) B0($) Sorted Suffixes
.=</p>
<p>0 C $1
0 C $2
.=</p>
<p>Helpful to think of BWT and LCP as being in σ + 1 “segments” labelled
according to the first symbol of associated suffix:
bwt0(S) = B0($) and lcp0(S) = L0($)..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>LCP of a massive collection of sequences Example
.=</p>
<p>Example: Iteration 0
.=</p>
<p>Let S = {S1, S2} = {ACACTGTACCAAC,GAACAGAAAGCTC} be
a collection of m = 2 strings of length k = 13 on an alphabet of σ = 4
letters.
.=</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>S1 C $1
S2 C $2
.=</p>
<p>We assume that the first element of LCP array is 0. Recall that
lcp($1, $2) = 0. We obtain:
.=</p>
<p>L0($) B0($) Sorted Suffixes
.=</p>
<p>0 C $1
0 C $2
.=</p>
<p>Helpful to think of BWT and LCP as being in σ + 1 “segments” labelled
according to the first symbol of associated suffix:
bwt0(S) = B0($) and lcp0(S) = L0($)..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A A
.=</p>
<p>C T
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example: Iteration 1
.=</p>
<p>Let S = {S1, S2} = {ACACTGTACCAAC,GAACAGAAAGCTC} be
a collection of m = 2 strings of length k = 13 on an alphabet of σ = 4
letters.
.=</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>S1 C $1
S2 C $2
.=</p>
<p>L0($) B0($) Sorted Suffixes
.=</p>
<p>0 C $1
0 C $2
.=</p>
<p>L1(C) B1(C) Sorted Suffixes
.=</p>
<p>0 A C$1
1 T C$2
.=</p>
<p>We recall that bwt1(S) = B1($)B1(A) · · ·B1(T ) and lcp1(S) = L1($)L1(A) · · ·L1(T )..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A
.=</p>
<p>C
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example: Iteration 1
.=</p>
<p>Let S = {S1, S2} = {ACACTGTACCAAC,GAACAGAAAGCTC} be
a collection of m = 2 strings of length k = 13 on an alphabet of σ = 4
letters.
.=</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>S1 A C $1
S2 T C $2
.=</p>
<p>L0($) B0($) Sorted Suffixes
.=</p>
<p>0 C $1
0 C $2
.=</p>
<p>L1(C) B1(C) Sorted Suffixes
.=</p>
<p>0 A C$1
1 T C$2
.=</p>
<p>We recall that bwt1(S) = B1($)B1(A) · · ·B1(T ) and lcp1(S) = L1($)L1(A) · · ·L1(T )..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A
.=</p>
<p>C
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example: Iteration 1
.=</p>
<p>Let S = {S1, S2} = {ACACTGTACCAAC,GAACAGAAAGCTC} be
a collection of m = 2 strings of length k = 13 on an alphabet of σ = 4
letters.
.=</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>S1 A C $1
S2 T C $2
.=</p>
<p>L1($) B1($) Sorted Suffixes
.=</p>
<p>0 C $1
0 C $2
.=</p>
<p>L1(C) B1(C) Sorted Suffixes
.=</p>
<p>0 A C$1
1 T C$2
.=</p>
<p>We recall that bwt1(S) = B1($)B1(A) · · ·B1(T ) and lcp1(S) = L1($)L1(A) · · ·L1(T )..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>LCP of a massive collection of sequences Example
.=</p>
<p>Example: Iteration 1
.=</p>
<p>Let S = {S1, S2} = {ACACTGTACCAAC,GAACAGAAAGCTC} be
a collection of m = 2 strings of length k = 13 on an alphabet of σ = 4
letters.
.=</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13
.=</p>
<p>S1 A A C $1
S2 C T C $2
.=</p>
<p>L1($) B1($) Sorted Suffixes
.=</p>
<p>0 C $1
0 C $2
.=</p>
<p>L1(C) B1(C) Sorted Suffixes
.=</p>
<p>0 A C$1
1 T C$2
.=</p>
<p>We recall that bwt1(S) = B1($)B1(A) · · ·B1(T ) and lcp1(S) = L1($)L1(A) · · ·L1(T )..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>min = 2
.=</p>
<p>→ 1+1=2 $1 ACACTGTACCAAC$1
min = 0
.=</p>
<p>min = 1
.=</p>
<p>min = 2
.=</p>
<p>→ 2+1=3 $2 GAACAGAAAGCTC$2
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example: Looking in detail at iteration 13
L12($) B12($) Sorted Suffixes L13($) B13($) Sorted Suffixes
.=</p>
<p>0 C $1 0 C $1
0 C $2 0 C $2
.=</p>
<p>L12(A) B12(A) Sorted Suffixes L13(A) B13(A) Sorted Suffixes
0 G AAAGCTC$2 0 G AAAGCTC$2
2 C AAC$1 2 C AAC$1
.=</p>
<p>→ 3 G AACAGAAAGCTC$2 3 G AACAGAAAGCTC$2
2 A AAGCTC$2 2 A AAGCTC$2
1 A AC$1 1 A AC$1
2 A ACAGAAAGCTC$2
2 T ACCAAC$1 2 A ACAGAAAGCTC$2
2 C ACTGTACCAAC$1 2 T ACCAAC$1
1 C AGAAAGCTC$2 2 C ACTGTACCAAC$1
2 A AGCTC$2 1 C AGAAAGCTC$2
.=</p>
<p>2 A AGCTC$2
L12(C) B12(C) Sorted Suffixes L13(C) B13(C) Sorted Suffixes
.=</p>
<p>0 A C$1 0 A C$1
1 T C$2 1 T C$2
1 C CAAC$1 1 C CAAC$1
.=</p>
<p>→ 2 A CACTGTACCAAC$1 2 G CACTGTACCAAC$1
2 A CAGAAAGCTC$2 2 A CAGAAAGCTC$2
1 A CCAAC$1 1 A CCAAC$1
1 G CTC$2 1 G CTC$2
2 A CTGTACCAAC$1 2 A CTGTACCAAC$1
.=</p>
<p>L12(G) B12(G) Sorted Suffixes L13(G) B13(G) Sorted Suffixes
0 A GAAAGCTC$2 0 A GAAAGCTC$2
1 A GCTC$2
1 T GTACCAAC$1 1 A GCTC$2
.=</p>
<p>1 T GTACCAAC$1
L12(T ) B12(T ) Sorted Suffixes L13(T ) B13(T ) Sorted Suffixes
.=</p>
<p>0 G TACCAAC$1 0 G TACCAAC$1
1 C TC$2 1 C TC$2
1 C TGTACCAAC$1 1 C TGTACCAAC$1.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>min = 2
.=</p>
<p>min = 0
.=</p>
<p>min = 2
.=</p>
<p>→ 2+1=3 $2 GAACAGAAAGCTC$2
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example: Looking in detail at iteration 13
L12($) B12($) Sorted Suffixes L13($) B13($) Sorted Suffixes
.=</p>
<p>0 C $1 0 C $1
0 C $2 0 C $2
.=</p>
<p>L12(A) B12(A) Sorted Suffixes L13(A) B13(A) Sorted Suffixes
0 G AAAGCTC$2 0 G AAAGCTC$2
2 C AAC$1 2 C AAC$1
.=</p>
<p>→ 3 G AACAGAAAGCTC$2 3 G AACAGAAAGCTC$2
2 A AAGCTC$2 2 A AAGCTC$2
1 A AC$1 1 A AC$1
2 A ACAGAAAGCTC$2→ 1+1=2 $1 ACACTGTACCAAC$1
2 T ACCAAC$1 2 A ACAGAAAGCTC$2
2 C ACTGTACCAAC$1 2 T ACCAAC$1
1 C AGAAAGCTC$2 2 C ACTGTACCAAC$1
2 A AGCTC$2 1 C AGAAAGCTC$2
.=</p>
<p>2 A AGCTC$2
L12(C) B12(C) Sorted Suffixes L13(C) B13(C) Sorted Suffixes
.=</p>
<p>0 A C$1 0 A C$1
min = 1 1 T C$2 1 T C$2
.=</p>
<p>1 C CAAC$1 1 C CAAC$1
→ 2 A CACTGTACCAAC$1 2 G CACTGTACCAAC$1
.=</p>
<p>2 A CAGAAAGCTC$2 2 A CAGAAAGCTC$2
1 A CCAAC$1 1 A CCAAC$1
1 G CTC$2 1 G CTC$2
2 A CTGTACCAAC$1 2 A CTGTACCAAC$1
.=</p>
<p>L12(G) B12(G) Sorted Suffixes L13(G) B13(G) Sorted Suffixes
0 A GAAAGCTC$2 0 A GAAAGCTC$2
1 A GCTC$2
1 T GTACCAAC$1 1 A GCTC$2
.=</p>
<p>1 T GTACCAAC$1
L12(T ) B12(T ) Sorted Suffixes L13(T ) B13(T ) Sorted Suffixes
.=</p>
<p>0 G TACCAAC$1 0 G TACCAAC$1
1 C TC$2 1 C TC$2
1 C TGTACCAAC$1 1 C TGTACCAAC$1.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>min = 2
.=</p>
<p>min = 0
.=</p>
<p>→ 2+1=3 $2 GAACAGAAAGCTC$2
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example: Looking in detail at iteration 13
L12($) B12($) Sorted Suffixes L13($) B13($) Sorted Suffixes
.=</p>
<p>0 C $1 0 C $1
0 C $2 0 C $2
.=</p>
<p>L12(A) B12(A) Sorted Suffixes L13(A) B13(A) Sorted Suffixes
0 G AAAGCTC$2 0 G AAAGCTC$2
2 C AAC$1 2 C AAC$1
.=</p>
<p>→ 3 G AACAGAAAGCTC$2 3 G AACAGAAAGCTC$2
2 A AAGCTC$2 2 A AAGCTC$2
1 A AC$1 1 A AC$1
2 A ACAGAAAGCTC$2→ 1+1=2 $1 ACACTGTACCAAC$1
2 T ACCAAC$1 2+1=3 A ACAGAAAGCTC$2
2 C ACTGTACCAAC$1 2 T ACCAAC$1
1 C AGAAAGCTC$2 2 C ACTGTACCAAC$1
2 A AGCTC$2 1 C AGAAAGCTC$2
.=</p>
<p>2 A AGCTC$2
L12(C) B12(C) Sorted Suffixes L13(C) B13(C) Sorted Suffixes
.=</p>
<p>0 A C$1 0 A C$1
min = 1 1 T C$2 1 T C$2
.=</p>
<p>1 C CAAC$1 1 C CAAC$1
→ 2 A CACTGTACCAAC$1 2 G CACTGTACCAAC$1
.=</p>
<p>min = 2 2 A CAGAAAGCTC$2 2 A CAGAAAGCTC$2
1 A CCAAC$1 1 A CCAAC$1
1 G CTC$2 1 G CTC$2
2 A CTGTACCAAC$1 2 A CTGTACCAAC$1
.=</p>
<p>L12(G) B12(G) Sorted Suffixes L13(G) B13(G) Sorted Suffixes
0 A GAAAGCTC$2 0 A GAAAGCTC$2
1 A GCTC$2
1 T GTACCAAC$1 1 A GCTC$2
.=</p>
<p>1 T GTACCAAC$1
L12(T ) B12(T ) Sorted Suffixes L13(T ) B13(T ) Sorted Suffixes
.=</p>
<p>0 G TACCAAC$1 0 G TACCAAC$1
1 C TC$2 1 C TC$2
1 C TGTACCAAC$1 1 C TGTACCAAC$1.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>min = 0
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>Example: Looking in detail at iteration 13
L12($) B12($) Sorted Suffixes L13($) B13($) Sorted Suffixes
.=</p>
<p>0 C $1 0 C $1
0 C $2 0 C $2
.=</p>
<p>L12(A) B12(A) Sorted Suffixes L13(A) B13(A) Sorted Suffixes
0 G AAAGCTC$2 0 G AAAGCTC$2
.=</p>
<p>min = 2 2 C AAC$1 2 C AAC$1
→ 3 G AACAGAAAGCTC$2 3 G AACAGAAAGCTC$2
.=</p>
<p>2 A AAGCTC$2 2 A AAGCTC$2
1 A AC$1 1 A AC$1
2 A ACAGAAAGCTC$2→ 1+1=2 $1 ACACTGTACCAAC$1
2 T ACCAAC$1 2+1=3 A ACAGAAAGCTC$2
2 C ACTGTACCAAC$1 2 T ACCAAC$1
1 C AGAAAGCTC$2 2 C ACTGTACCAAC$1
2 A AGCTC$2 1 C AGAAAGCTC$2
.=</p>
<p>2 A AGCTC$2
L12(C) B12(C) Sorted Suffixes L13(C) B13(C) Sorted Suffixes
.=</p>
<p>0 A C$1 0 A C$1
min = 1 1 T C$2 1 T C$2
.=</p>
<p>1 C CAAC$1 1 C CAAC$1
→ 2 A CACTGTACCAAC$1 2 G CACTGTACCAAC$1
.=</p>
<p>min = 2 2 A CAGAAAGCTC$2 2 A CAGAAAGCTC$2
1 A CCAAC$1 1 A CCAAC$1
1 G CTC$2 1 G CTC$2
2 A CTGTACCAAC$1 2 A CTGTACCAAC$1
.=</p>
<p>L12(G) B12(G) Sorted Suffixes L13(G) B13(G) Sorted Suffixes
0 A GAAAGCTC$2 0 A GAAAGCTC$2
1 A GCTC$2 → 2+1=3 $2 GAACAGAAAGCTC$2
1 T GTACCAAC$1 1 A GCTC$2
.=</p>
<p>1 T GTACCAAC$1
L12(T ) B12(T ) Sorted Suffixes L13(T ) B13(T ) Sorted Suffixes
.=</p>
<p>0 G TACCAAC$1 0 G TACCAAC$1
1 C TC$2 1 C TC$2
1 C TGTACCAAC$1 1 C TGTACCAAC$1.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>LCP of a massive collection of sequences Example
.=</p>
<p>Example: Looking in detail at iteration 13
L12($) B12($) Sorted Suffixes L13($) B13($) Sorted Suffixes
.=</p>
<p>0 C $1 0 C $1
0 C $2 0 C $2
.=</p>
<p>L12(A) B12(A) Sorted Suffixes L13(A) B13(A) Sorted Suffixes
0 G AAAGCTC$2 0 G AAAGCTC$2
.=</p>
<p>min = 2 2 C AAC$1 2 C AAC$1
→ 3 G AACAGAAAGCTC$2 3 G AACAGAAAGCTC$2
.=</p>
<p>2 A AAGCTC$2 2 A AAGCTC$2
1 A AC$1 1 A AC$1
2 A ACAGAAAGCTC$2→ 1+1=2 $1 ACACTGTACCAAC$1
.=</p>
<p>min = 0 2 T ACCAAC$1 2+1=3 A ACAGAAAGCTC$2
2 C ACTGTACCAAC$1 2 T ACCAAC$1
1 C AGAAAGCTC$2 2 C ACTGTACCAAC$1
2 A AGCTC$2 1 C AGAAAGCTC$2
.=</p>
<p>2 A AGCTC$2
L12(C) B12(C) Sorted Suffixes L13(C) B13(C) Sorted Suffixes
.=</p>
<p>0 A C$1 0 A C$1
min = 1 1 T C$2 1 T C$2
.=</p>
<p>1 C CAAC$1 1 C CAAC$1
→ 2 A CACTGTACCAAC$1 2 G CACTGTACCAAC$1
.=</p>
<p>min = 2 2 A CAGAAAGCTC$2 2 A CAGAAAGCTC$2
1 A CCAAC$1 1 A CCAAC$1
1 G CTC$2 1 G CTC$2
2 A CTGTACCAAC$1 2 A CTGTACCAAC$1
.=</p>
<p>L12(G) B12(G) Sorted Suffixes L13(G) B13(G) Sorted Suffixes
0 A GAAAGCTC$2 0 A GAAAGCTC$2
1 A GCTC$2 → 2+1=3 $2 GAACAGAAAGCTC$2
1 T GTACCAAC$1 0+1=1 A GCTC$2
.=</p>
<p>1 T GTACCAAC$1
L12(T ) B12(T ) Sorted Suffixes L13(T ) B13(T ) Sorted Suffixes
.=</p>
<p>0 G TACCAAC$1 0 G TACCAAC$1
1 C TC$2 1 C TC$2
1 C TGTACCAAC$1 1 C TGTACCAAC$1.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>min = 2
.=</p>
<p>min = 0
.=</p>
<p>min = 1
.=</p>
<p>min = 2
.=</p>
<p>LCP of a massive collection of sequences Example
.=</p>
<p>When are the minimum values computed?
L12($) B12($) Sorted Suffixes
.=</p>
<p>0 C $1
0 C $2
.=</p>
<p>L12(A) B12(A) Sorted Suffixes
.=</p>
<p>We can compute the minimum 0 G AAAGCTC$2
2 C AAC$1
.=</p>
<p>values useful for the iteration j → 3 G AACAGAAAGCTC$2
2 A AAGCTC$2
.=</p>
<p>while we are inserting the new 1 A AC$1
2 A ACAGAAAGCTC$2
.=</p>
<p>elements in the partial BWT and in 2 T ACCAAC$1
2 C ACTGTACCAAC$1
.=</p>
<p>the partial LCP in a sequential way 1 C AGAAAGCTC$2
2 A AGCTC$2
.=</p>
<p>during the iteration j − 1.
L12(C) B12(C) Sorted Suffixes
.=</p>
<p>0 A C$1
In the example, while we build 1 T C$2
.=</p>
<p>1 C CAAC$
B(12) and L(12) segments, we can
.=</p>
<p>1
→ 2 A CACTGTACCAAC$1
.=</p>
<p>2 A CAGAAAGCTC$
compute the minimum values useful 21 A CCAAC$1
.=</p>
<p>1 G CTC$
for the computation of LCP-values 22 A CTGTACCAAC$1
corresponding to 13-suffixes. L12(G) B12(G) Sorted Suffixes0 A GAAAGCTC$2
.=</p>
<p>1 A GCTC$2
.=</p>
<p>We can compute minimum values 1 T GTACCAAC$1
.=</p>
<p>at the same time for all j-suffixes. L12(T ) B12(T ) Sorted Suffixes
0 G TACCAAC$1
1 C TC$2
1 C TGTACCAAC$1.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>LCP of a massive collection of sequences Example
.=</p>
<p>When are the minimum values computed?
L12($) B12($) Sorted Suffixes
.=</p>
<p>0 C $1
0 C $2
.=</p>
<p>L12(A) B12(A) Sorted Suffixes
.=</p>
<p>We can compute the minimum 0 G AAAGCTC$2
min = 2 2 C AAC$1
.=</p>
<p>values useful for the iteration j → 3 G AACAGAAAGCTC$2
2 A AAGCTC$2
.=</p>
<p>while we are inserting the new 1 A AC$1
2 A ACAGAAAGCTC$2
.=</p>
<p>elements in the partial BWT and in min = 0 2 T ACCAAC$1
2 C ACTGTACCAAC$1
.=</p>
<p>the partial LCP in a sequential way 1 C AGAAAGCTC$2
2 A AGCTC$2
.=</p>
<p>during the iteration j − 1.
L12(C) B12(C) Sorted Suffixes
.=</p>
<p>0 A C$1
In the example, while we build min = 1 1 T C$2
.=</p>
<p>1 C CAAC$
B(12) and L(12) segments, we can
.=</p>
<p>1
→ 2 A CACTGTACCAAC$1
.=</p>
<p>min = 2 2 A CAGAAAGCTC$
compute the minimum values useful 21 A CCAAC$1
.=</p>
<p>1 G CTC$
for the computation of LCP-values 22 A CTGTACCAAC$1
corresponding to 13-suffixes. L12(G) B12(G) Sorted Suffixes0 A GAAAGCTC$2
.=</p>
<p>1 A GCTC$2
.=</p>
<p>We can compute minimum values 1 T GTACCAAC$1
.=</p>
<p>at the same time for all j-suffixes. L12(T ) B12(T ) Sorted Suffixes
0 G TACCAAC$1
1 C TC$2
1 C TGTACCAAC$1.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Conclusions Advantages
.=</p>
<p>Advantages
.=</p>
<p>The BWT and the LCP are split and kept in σ files.
Sequentially reading.
Each iteration j > 0 can be divided into two consecutive phases:
First phase: we read only the segments Bj−1 in order to find the
.=</p>
<p>positions where we must insert the elements associated
with the j-suffixes.
.=</p>
<p>Second phase: we read the segments Bj−1 and Lj−1 in sequential
way for the construction of new segments Bj and Lj
and compute the minimum LCP-values for the next
iteration.
.=</p>
<p>Inserting/updating simultaneously of m symbols in the partial BWT
and 2m values in the partial LCP and computing simultaneously the
2m minimum LCP-values for the next iteration.
.=</p>
<p>Moreover, at any iteration j, we can stop the running and by adding the
elements corresponding to the end-markers we can obtain the BWT and
LCP of the collection of the j-suffixes of S..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Conclusions Experiments
.=</p>
<p>Experiments
.=</p>
<p>Notice that an entirely like-for-like comparison between our
implementation and the existing implementation requires the
concatenation of the strings of the collection, but
.=</p>
<p>The use of many millions of different end markers could be not
practicable.
.=</p>
<p>The use of the same end marker could lead to values in the LCP array
that may exceed the lengths of the strings.
.=</p>
<p>However, preliminary comparisons have shown that our algorithm
uses less internal memory than these algorithms..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Conclusions Experiments
.=</p>
<p>In particular
.=</p>
<p>bwt based laca21 computes the LCP of a single string and needs
the pre-computed BWT of the string.
.=</p>
<p>In order to adapt this algorithm for a collection, we have computed
the BWT of a collection by using BCR . Such output needs slight
modifications because, in general, the BWT of a collection does not
coincide with the BWT of a single string.
.=</p>
<p>Result
BCR requires about 5 hours of wallclock time taking only 4Gb of RAM
+ LCP (computed by bwt based laca2) requires 18Gb of RAM to
create the LCP in about 2 hours.
Our new method extLCP needs 4.7Gb of RAM to create both BWT
and LCP in just under 18 hours.
.=</p>
<p>Attempting to use bwt based laca2 to compute the LCP of 800
million of sequences 100 bases long exceeds our available RAM on the
64Gb RAM machine.
.=</p>
<p>1
T. Beller, S. Gog, E. Ohlebusch, and T. Schnattinger. Computing the longest common prefix array based on
.=</p>
<p>the Burrows-Wheeler transform. Journal of Discrete Algorithms. To appear..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Conclusions Experiments
.=</p>
<p>Experiments
.=</p>
<p>instance size in Gb program wall clock efficiency memory
.=</p>
<p>0043M 4.00 BCR 0.99 0.84 0.57
4.00 extLCP 3.29 0.98 1.00
.=</p>
<p>0085M 8.00 BCR 1.01 0.83 1.10
8.00 extLCP 3.81 0.87 2.00
.=</p>
<p>0100M 9.31 BCR 1.05 0.81 1.35
9.31 extLCP 4.03 0.83 2.30
.=</p>
<p>0200M 18.62 BCR 1.63 0.58 4.00
18.62 extLCP 4.28 0.79 4.70
.=</p>
<p>0800M 74.51 BCR 3.23 0.43 10.40
74.51 extLCP 6.68 0.67 18.00
.=</p>
<p>All reads are 100 bases long.
.=</p>
<p>wall clock time (the amount of time that elapsed from the start to the completion of the instance) is given as
microseconds per input base.
.=</p>
<p>memory denotes the maximal amount of memory (in gigabytes) used during execution.
.=</p>
<p>The efficiency column states the CPU efficiency values, i.e. the proportion of time for which the CPU was occupied and
not waiting for I/O operations to finish, as taken from the output of the /usr/bin/time command.
.=</p>
<p>The extLCP algorithm:
.=</p>
<p>uses O(mk2 log σ) disk I/O and O((m+σ2) log(mk)) bits of memory.
.=</p>
<p>takes O(k(m+ sort(m)) CPU time, where sort(m) is the time taken
to sort m integers..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Conclusions Ongoing works
.=</p>
<p>Ongoing works
.=</p>
<p>Ongoing work:
.=</p>
<p>Further optimizations for the construction, for instance by using the
parallelization or by using different strategies for I/O operations.
Integrate the construction of LCP in the BEETL software library.
BEETL for construction/querying of BWT of large string collections
can be downloaded from
.=</p>
<p>http://beetl.github.com/BEETL
.=</p>
<p>Bioinformatics applications based on BWT and LCP and by using
extLCP.
.=</p>
<p>Many thanks for your attention!.=</p>
</div>
</body>
		<back>
			<div type="references">

				<listBibl>


				</listBibl>
			</div>
		</back>
	</text>
</TEI>
