<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /mnt/sda1/Dissertation/grobid/grobid-0.5.6/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Multi-agent reinforcement learning</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2019-12-22">December 22, 2019</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Schnebli</forename><surname>Zoltan</surname></persName>
						</author>
						<title level="a" type="main">Multi-agent reinforcement learning</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2019-12-22">December 22, 2019</date>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.5.6" ident="GROBID" when="2019-12-24T15:31+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>An Algorithm for
Multi-Unit
Combinatorial Auctions
.=</p>
<p>Kevin Leyton-Brown
Yoav Shoham
.=</p>
<p>Moshe Tennenholtz
.=</p>
<p>Computer Science Dept.
Stanford University
.=</p>
<p>thanks also to Shobha Venkataraman.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Combinatorial Auctions
Mechanisms that allow bidders to explicitly indicate 
complementarities and substitutabilities
.=</p>
<p>many goods are auctioned simultaneously
bids name an arbitrary bundle and a price offer
bidders may submit multiple bids
.=</p>
<p>if desired, some bids may be mutually exclusive
otherwise, more than one of a bidder’s bids may win
.=</p>
<p>Benefit: less risk for bidders
won’t win a subset of a bundle for more than it is worth to them
can request multiple mutually-exclusive bundles
More efficient / higher revenue
.=</p>
<p>no need to hedge bids or restrict bidding to a single bundle.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Multi-Unit CA’s
Sometimes a set of goods are identical
.=</p>
<p>traditionally, bidders have no way to compactly 
represent indifference between members of the set
.=</p>
<p>instead, they must enumerate bundles between which they 
are indifferent
this can require a huge number of bids
.=</p>
<p>Multi-Unit CA
set of identical goods: a single multi-unit good
.=</p>
<p>in general, consider all goods to have a fixed number of units
.=</p>
<p>bids specify goods, number of units for each good, a 
price offer for the whole package.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Winner Determination
Auctioneer’s task:
.=</p>
<p>given a set of bids, find the revenue-maximizing 
subset of these bids allocating no more than the 
maximum number of units for each good
.=</p>
<p>We can handle XOR with “dummy goods”
unique virtual goods with one unit
add a dummy good to every bid in an XOR set
now at most one bid from each set can be satisfied
.=</p>
<p>Same winner-determination procedure used by:
first-price combinatorial auction
generalized Vickrey auction
various ascending auction mechanisms.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Computational Problem
Unfortunately, winner determination is NP-Hard, 
even with only one unit per good
.=</p>
<p>Responses to intractability
approximation
restrict bids (tractable subcase)
find optimal solution anyway
.=</p>
<p>Benefits of finding optimal solution
constant-bounded approximation is still intractable
bidders’ strategies affected by approximation
restriction can prevent bidders from expressing full 
preferences.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Finding Optimal Solution
All previously-published work on CA’s has 
concerned single-unit case
A natural solution: mixed-integer 
programming
.=</p>
<p>rich history
commercial packages (CPLEX).=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>CAMUS
Combinatorial Auction Multi-Unit Search
.=</p>
<p>branch and bound search
structure the search space
.=</p>
<p>avoid considering impossible allocations
efficient upper-bound function for pruning
.=</p>
<p>enhancements
preprocessing dominated bids
dynamic programming
caching to improve tightness of upper-bound 
.=</p>
<p>heuristics
maximize effectiveness of pruning: upper bound 
find good allocations quickly: lower bound
.=</p>
<p>A generalization of our CASS algorithm (1999).=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>First: CAMUS/CPLEX comparison
Necessary to use artificial data for testing
.=</p>
<p>used a distribution from our new paper 
(to appear at EC-00)
aims to model bidding in real-world domains
.=</p>
<p>Railroad Shipping Domain: Railroad Graph
nodes: cities
edges: railroad link between cities
edge weights: link capacity.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Railroad Distribution
Randomly generate a graph
.=</p>
<p>random num units per edge: [1, max_units_per_good]
.=</p>
<p>Create a new bidder
randomly choose start and end cities, 
number of units to ship
valuation for route: random proportional to the 
distance, superadditive in number of units
generate substitutable bids for all bundles of edges 
where valuation > cost of shipping (c * distance)
price offer: valuation – cost, rounded to integer.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Railroad Distribution: Example
.=</p>
<p>Parameters: num_cities = 5.3 * goods + 3.5, initial_connections = 2, building_penalty = 2.7, 
num_building_paths = (num_cities)²/4, shipping_cost_factor = 1.1, 
.=</p>
<p>max_bid_set_size = 8, max_cap = 20, additivity = 0.2..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>10 goods:
CAMUS, CPLEX, Min Performance
.=</p>
<p>100000
.=</p>
<p>10000
.=</p>
<p>1000
.=</p>
<p>100
.=</p>
<p>10
.=</p>
<p>1
.=</p>
<p>0.1
400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 1700 1800 1900 2000 2100
.=</p>
<p>Number of Bids
.=</p>
<p>CAMUS - 10 CPLEX - 10 Min - 10
.=</p>
<p>Average over 10 Trials (s).=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>12 goods:
CAMUS, CPLEX, Min Performance
.=</p>
<p>100000
.=</p>
<p>10000
.=</p>
<p>1000
.=</p>
<p>100
.=</p>
<p>10
.=</p>
<p>1
.=</p>
<p>0.1
400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 1700 1800 1900 2000 2100
.=</p>
<p>Number of Bids
.=</p>
<p>CAMUS - 12 CPLEX - 12 Min - 12
.=</p>
<p>Average over 10 Trials (s).=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>CAMUS Implementation: Search
Depth-First Search on allocations
.=</p>
<p>begin with empty allocation
add bids to current partial allocation until 
complete; backtrack
.=</p>
<p>Branch and Bound Search
lower bound: best allocation observed so far
upper bound: revenue of current partial 
allocation + overestimate of revenue from 
unallocated units
when upper bound ≤ lower bound, backtrack.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Structure the Search Space
Partition the bids into bins
.=</p>
<p>one bin for each good
each bid belongs to the bin corresponding to its 
lowest-order good
.=</p>
<p>After adding a bid, move to the bin for the 
lowest-order good with unallocated units
.=</p>
<p>this may be the bin we just left (multi-unit!)
create a subbin of the current bin and keep searching
subbin: include only higher-order bids than the last bid 
chosen from this bin
.=</p>
<p>any bids that we skip are guaranteed to conflict with 
the current partial allocation.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Upper Bound Function h(g,i,π)
An overestimate of the revenue that can be achieved 
from the remaining units of good g
.=</p>
<p>given that the search is in bin i and has partial allocation π
precompute lists for all g, i:
.=</p>
<p>each list: all bids for units of good g in bin i or beyond
sorted in descending order of average price per unit (APPU)
.=</p>
<p>Let b be first bid in list i that doesn’t conflict with π
b’s contribution to the overestimate: 
APPU(b) * min(unitsi(b), units_neededi)
if more units are still needed, keep moving down the list and find 
another non-conflicting bid; repeat
.=</p>
<p>Why does this work?  Please see our paper….=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Dominated Bids
For each pair of bids (b1, b2), where:
.=</p>
<p>price(b1) ≥ price(b2)
for all goods j, unitsj(b1) ≤ unitsj (b2)
.=</p>
<p>b2 will not win unless b1 also wins
store b2 as a “child” of b1
.=</p>
<p>only consider adding b2 after adding b1
if unitsj(b1) + unitsj (b2) ≥ maxunitsj for any j
.=</p>
<p>we will never add b2: delete it.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Dynamic Programming
In some auctions, singleton bids will be relatively 
common
.=</p>
<p>Additionally, singleton bids can be computationally 
expensive to consider: can lead to deep searches
.=</p>
<p>Dynamic programming preprocessing:
find the optimal set of singleton bids requesting from 
1 to maxunitsj, for each good j
in search, only ever consider the optimal singleton set 
that consumes all remaining units of a good.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Caching
It is possible to allocate the same number of 
units of the same goods in more than one way
.=</p>
<p>the search beyond this point is always the same
store the results of search in a hash table, then reuse 
them if we get to the same point again
.=</p>
<p>most searches are pruned before they reach a full allocation, 
so we can’t store the best allocation in the cache
.=</p>
<p>use the cache to store upper bounds
only store the results that involved non-negligible cost to 
compute
cache upper bounds often tighter than h( )
.=</p>
<p>cache can be seen as learning a better h( )
a tighter upper bound.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Good-Ordering Heuristic
designate as good #1 the good i that minimizes 
(numbidsi · maxunitsi) / (avgunitsi)
.=</p>
<p>minimize number of bids in low-order bins
reduce branching
.=</p>
<p>minimize number of units of goods in low-order bins
move quickly past the first bins, where the pruning function is 
least informative
.=</p>
<p>maximize total number of units requested by bids in 
low-order bins 
.=</p>
<p>move quickly to high-order bins
.=</p>
<p>remove bids involving good #1 and repeat for 
good #2, etc..=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Bid-Ordering Heuristic
Order bids within bin so we encounter 
most promising bids first
.=</p>
<p>improve lower bound
Sort bids b in descending order of 
APPU(b) + h(π ∪ b)
.=</p>
<p>APPU(b) is a measure of b’s promise
h( ) is a measure of how promising the 
unallocated units are, given partial allocation
.=</p>
<p>This ordering is dynamic, because 
h(π ∪ b) depends on the past search.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>CAMUS vs. CPLEX
The jury’s still out
.=</p>
<p>CAMUS outperforms CPLEX on the railroad distribution
we’ve seen other cases where CPLEX is better
what are the strengths of each approach?
.=</p>
<p>Choice of distribution is fundamental to testing 
can we agree on distributions that capture the 
patterns we expect from real-world bidding?
Towards a Universal Test Suite for Combinatorial 
Auctions, http://robotics.stanford.edu/CATS
we’d love to get your feedback on this!.=</p>
</div>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Conclusion
CAMUS is a general-purpose algorithm for finding the 
winners of multi-unit combinatorial auctions
A branch and bound search:
.=</p>
<p>structuring the search space
preprocessing
dynamic programming
caching
heuristics for ordering goods and bids
.=</p>
<p>Promising performance when compared to CPLEX on our 
railroad distribution
.=</p>
<p>more work needed to understand strengths and weaknesses of 
each approach on other real-world CA distributions.=</p>
</div>
</body>
		<back>
			<div type="references">

				<listBibl>


				</listBibl>
			</div>
		</back>
	</text>
</TEI>
